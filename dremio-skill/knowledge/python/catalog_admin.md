# Catalog Admin

## Catalog & Admin

The `Catalog` class provides access to Dremio's catalog and administrative functions via the REST API.

## Accessing the Catalog

You can access the catalog through the `DremioClient` instance:

```python
from dremioframe.client import DremioClient

client = DremioClient()
catalog = client.catalog
```

## Listing Items

To list the contents of the root catalog or a specific path:

```python
# List root catalog
items = catalog.list_catalog()
for item in items:
    print(item['path'], item['type'])

# List contents of a source or folder
items = catalog.list_catalog("Samples")
```

## Managing Sources

You can create and delete sources:

```python
# Create a source (example for S3)
config = {
    "bucketName": "my-bucket",
    "authenticationType": "ACCESS_KEY",
    "accessKey": "...",
    "accessSecret": "..."
}
catalog.create_source("MyS3Source", "S3", config)

# Delete a source
catalog.delete_catalog_item("source-id-uuid")
```

## Managing Views

You can create and update virtual datasets (views). The `sql` argument accepts either a raw SQL string or a `DremioBuilder` object (DataFrame).

```python
# Create a view using SQL string
catalog.create_view(
    path=["Space", "MyView"],
    sql="SELECT * FROM source.table"
)

# Create a view using a DataFrame (Builder)
df = client.table("source.table").filter("id > 100")
catalog.create_view(
    path=["Space", "FilteredView"],
    sql=df
)
```

---

## Dataset Tagging

DremioFrame allows you to manage tags for datasets (tables and views) using the `Catalog` client. Tags are useful for organizing and classifying data assets (e.g., "PII", "Gold", "Deprecated").

## Usage

Access tagging methods via `client.catalog`.

### Get Tags

Retrieve the current tags for a dataset using its ID.

```python
from dremioframe.client import DremioClient

client = DremioClient()
dataset_id = "..." # Get ID via client.catalog.get_entity(...)

tags = client.catalog.get_tags(dataset_id)
print(tags) # e.g. ["pii", "sales"]
```

### Set Tags

Set the tags for a dataset. **Note:** This overwrites existing tags.

```python
# To safely update tags, it's recommended to fetch the current version first
# to avoid conflicts if tags were modified concurrently.

# 1. Get current tag info (includes version)
tag_info = client.catalog.get_tag_info(dataset_id)
current_version = tag_info.get("version")
current_tags = tag_info.get("tags", [])

# 2. Modify tags
new_tags = current_tags + ["new-tag"]

# 3. Set tags with version
client.catalog.set_tags(dataset_id, new_tags, version=current_version)
```

### Remove Tags

To remove all tags, pass an empty list.

```python
client.catalog.set_tags(dataset_id, [], version=current_version)
```


---

<!-- Source: docs/admin_governance/udf.md -->

---

## Documenting Datasets

Documentation is critical for a self-service data platform. Dremio allows you to attach a Wiki (Markdown) and Tags to every dataset, source, space, and folder.

## Wikis

The Wiki is the first thing users see when they open a dataset in Dremio. It should provide context, ownership, and usage instructions.

### Updating Wikis Programmatically

You can automate documentation updates using `client.catalog.update_wiki`.

```python
# Get the dataset ID
dataset = client.catalog.get_entity_by_path("marketing.customer_360")
dataset_id = dataset['id']

# Define Wiki Content (Markdown)
wiki_content = """
# Customer 360

This view provides a holistic view of customer activity, aggregated at the user level.

## Key Metrics
- **Lifetime Value (LTV)**: Total revenue generated by the customer.
- **Total Orders**: Count of all completed orders.

## Usage
Use this view for:
- Churn analysis
- Segmentation
- Email marketing campaigns

## Owner
**Marketing Data Team** (marketing-data@example.com)
"""

# Get current wiki version (required for updates to avoid 409 Conflict)
try:
    current_wiki = client.catalog.get_wiki(dataset_id)
    version = current_wiki.get("version")
except Exception:
    version = None

# Update the Wiki
client.catalog.update_wiki(dataset_id, wiki_content, version=version)
```

> [!NOTE]
> When updating a Wiki, it is best practice to fetch the current version first and pass it to `update_wiki`. This prevents overwriting concurrent changes and avoids `409 Conflict` errors, which are common in Dremio Software.

### Retrieving Wiki Content

```python
wiki = client.catalog.get_wiki(dataset_id)
print(wiki.get("text"))
```

## Tagging

Tags help organize and discover datasets. You can use tags to indicate status, department, or project.

### Best Practices for Tags
- **Status**: `production`, `staging`, `deprecated`
- **Department**: `marketing`, `finance`, `engineering`
- **Compliance**: `pii`, `gdpr`, `hipaa`

### Managing Tags

```python
# Tag the dataset as 'certified' and 'production'
# Note: set_tags overwrites existing tags
client.catalog.set_tags(dataset_id, ["certified", "production", "marketing"])

# Retrieve tags to verify
tags = client.catalog.get_tags(dataset_id)
print(tags) # ['certified', 'production', 'marketing']
```


---

<!-- Source: docs/modeling/medallion.md -->

---

## Grants and Privileges

DremioFrame allows you to manage access control lists (grants) for catalog entities (datasets, folders, sources).

## Usage

Access grants via `client.catalog`.

### Get Grants

Retrieve the current grants for an entity.

```python
from dremioframe.client import DremioClient

client = DremioClient()
entity_id = "..." 

grants_info = client.catalog.get_grants(entity_id)
print(grants_info)
# Output example:
# {
#   "grants": [
#     {"granteeType": "USER", "id": "...", "privileges": ["SELECT", "ALTER"]},
#     {"granteeType": "ROLE", "id": "...", "privileges": ["SELECT"]}
#   ],
#   "availablePrivileges": ["SELECT", "ALTER", "MANAGE_GRANTS", ...]
# }
```

### Set Grants

Update the grants for an entity. **Note:** This replaces the existing grants list.

```python
new_grants = [
    {
        "granteeType": "USER",
        "id": "user-uuid-...",
        "privileges": ["SELECT"]
    }
]

client.catalog.set_grants(entity_id, new_grants)
```


---

<!-- Source: docs/admin_governance/reflections.md -->

---

## List root catalog
dremio-cli catalog

---

## List specific path
dremio-cli catalog --path "source.folder"
```

### List Reflections

```bash
dremio-cli reflections
```


---

<!-- Source: docs/reference/client.md -->

# Client API Reference

::: dremioframe.client.DremioClient
    options:
      show_root_heading: true
      show_source: true

::: dremioframe.client.AsyncDremioClient
    options:
      show_root_heading: true
      show_source: true

# Client Helpers

These classes are accessed via properties on the `DremioClient` instance (e.g., `client.admin`, `client.catalog`).

## Admin

::: dremioframe.admin.Admin
    options:
      show_root_heading: true
      show_source: true

## Catalog

::: dremioframe.catalog.Catalog
    options:
      show_root_heading: true
      show_source: true

## Iceberg

::: dremioframe.iceberg.Iceberg
    options:
      show_root_heading: true
      show_source: true

## UDF

::: dremioframe.udf.UDF
    options:
      show_root_heading: true
      show_source: true

## Profile

::: dremioframe.profile.Profile
    options:
      show_root_heading: true
      show_source: true


---

<!-- Source: docs/reference/dq.md -->

# Data Quality API Reference

::: dremioframe.dq.runner.DQRunner
    options:
      show_root_heading: true

::: dremioframe.dq.checks.DataQuality
    options:
      show_root_heading: true


---

<!-- Source: docs/reference/function_reference.md -->

# Function Reference

This document lists the SQL functions supported by `dremioframe.functions`.

## General Functions

- `col(name)`: Creates a column expression.
- `lit(val)`: Creates a literal expression.

## Aggregates

- `sum(col)`: Calculates the sum of a column.
- `avg(col)`: Calculates the average of a column.
- `min(col)`: Finds the minimum value in a column.
- `max(col)`: Finds the maximum value in a column.
- `count(col)`: Counts the number of non-null values in a column.
- `stddev(col)`: Calculates the standard deviation.
- `variance(col)`: Calculates the variance.
- `approx_distinct(col)`: Approximates the count of distinct values.

## Math

- `abs(col)`: Absolute value.
- `ceil(col)`: Ceiling.
- `floor(col)`: Floor.
- `round(col, scale=0)`: Rounds to the specified scale.
- `sqrt(col)`: Square root.
- `exp(col)`: Exponential.
- `ln(col)`: Natural logarithm.
- `log(base, col)`: Logarithm with specified base.
- `pow(col, power)`: Power.

## String

- `upper(col)`: Converts to uppercase.
- `lower(col)`: Converts to lowercase.
- `concat(*cols)`: Concatenates strings.
- `substr(col, start, length=None)`: Substring.
- `trim(col)`: Trims whitespace from both ends.
- `ltrim(col)`: Trims whitespace from left.
- `rtrim(col)`: Trims whitespace from right.
- `length(col)`: String length.
- `replace(col, pattern, replacement)`: Replaces occurrences of pattern.
- `regexp_replace(col, pattern, replacement)`: Replaces using regex.
- `initcap(col)`: Capitalizes first letter of each word.

## Date/Time

- `current_date()`: Current date.
- `current_timestamp()`: Current timestamp.
- `date_add(col, days)`: Adds days to date.
- `date_sub(col, days)`: Subtracts days from date.
- `date_diff(col1, col2)`: Difference in days between dates.
- `to_date(col, fmt=None)`: Converts string to date.
- `to_timestamp(col, fmt=None)`: Converts string to timestamp.
- `year(col)`: Extracts year.
- `month(col)`: Extracts month.
- `day(col)`: Extracts day.
- `hour(col)`: Extracts hour.
- `minute(col)`: Extracts minute.
- `second(col)`: Extracts second.
- `extract(field, source)`: Extracts field from source.

## Conditional

- `coalesce(*cols)`: Returns first non-null value.
- `when(condition, value)`: Starts a CASE statement builder.

## Window Functions

- `rank()`: Rank.
- `dense_rank()`: Dense rank.
- `row_number()`: Row number.
- `lead(col, offset=1, default=None)`: Lead.
- `lag(col, offset=1, default=None)`: Lag.
- `first_value(col)`: First value in window.
- `last_value(col)`: Last value in window.
- `ntile(n)`: N-tile.

## AI Functions

- `ai_classify(prompt, categories, model_name=None)`: Classifies text into categories.
- `ai_complete(prompt, model_name=None)`: Generates text completion.
- `ai_generate(prompt, model_name=None, schema=None)`: Generates structured data.

## Complex Types

- `flatten(col)`: Explodes a list into multiple rows.
- `convert_from(col, type_)`: Converts from serialized format.
- `convert_to(col, type_)`: Converts to serialized format.


---

<!-- Source: docs/reference/functions/aggregate.md -->

# Aggregate Functions

Aggregate functions operate on a set of values to compute a single result.

## Usage

```python
from dremioframe import F

df.group_by("dept").agg(
    total=F.sum("salary"),
    count=F.count("*")
)
```

## Available Functions

| Function | Description |
| :--- | :--- |
| `sum(col)` | Returns the sum of values in the column. |
| `avg(col)` | Returns the average of values in the column. |
| `min(col)` | Returns the minimum value. |
| `max(col)` | Returns the maximum value. |
| `count(col)` | Returns the count of non-null values. Use `*` for total rows. |
| `stddev(col)` | Returns the sample standard deviation. |
| `variance(col)` | Returns the sample variance. |
| `approx_distinct(col)` | Returns the approximate number of distinct values (HyperLogLog). |


---

<!-- Source: docs/reference/functions/ai.md -->

# AI Functions

Dremio provides AI-powered functions for classification, text completion, and structured data generation.

## Usage

```python
from dremioframe import F

---

## Row Access and Column Masking

`dremioframe` provides methods to manage Dremio's Row Access and Column Masking policies, allowing you to secure your data dynamically.

## User Defined Functions (UDFs)

Policies rely on User Defined Functions (UDFs) to define the logic for access control and masking.

### Creating a UDF

Use `admin.create_udf` (which delegates to `client.udf.create`) to create a UDF.

```python
from dremioframe.client import DremioClient

client = DremioClient(pat="...", project_id="...")

# Create a masking UDF
client.admin.create_udf(
    name="target.protect_ssn",
    args="ssn VARCHAR",
    return_type="VARCHAR",
    body="CASE WHEN is_member('hr') THEN ssn ELSE '***-**-****' END",
    replace=True
)

# Create a row access UDF
client.admin.create_udf(
    name="target.region_filter",
    args="region VARCHAR",
    return_type="BOOLEAN",
    body="is_member('sales') OR region = 'public'",
    replace=True
)
```

### Dropping a UDF

```python
client.admin.drop_udf("target.protect_ssn", if_exists=True)
```

## Column Masking Policies

Column masking policies dynamically mask data in a column based on a UDF.

### Applying a Masking Policy

```python
# Apply the 'protect_ssn' UDF to the 'ssn' column of 'employees' table
client.admin.apply_masking_policy(
    table="target.employees",
    column="ssn",
    policy="target.protect_ssn(ssn)"
)
```

### Removing a Masking Policy

```python
# Unset the masking policy
client.admin.drop_masking_policy(
    table="target.employees",
    column="ssn",
    policy="target.protect_ssn" # Optional, but good practice to specify
)
```

## Row Access Policies

Row access policies filter rows based on a UDF.

### Applying a Row Access Policy

```python
# Apply the 'region_filter' UDF to the 'employees' table
client.admin.apply_row_access_policy(
    table="target.employees",
    policy="target.region_filter(region)"
)
```

### Removing a Row Access Policy

```python
# Drop the row access policy
client.admin.drop_row_access_policy(
    table="target.employees",
    policy="target.region_filter(region)"
)
```


---

<!-- Source: docs/admin_governance/privileges.md -->

---

## Space and Folder Management

DremioFrame provides methods to manage Spaces and Folders in both Dremio Cloud and Dremio Software.

## Methods

### `create_folder`

Creates a folder using SQL. This is the primary method for creating folders in Dremio Cloud and Iceberg Catalogs.

```python
client.admin.create_folder("my_space.my_folder")
```

**Syntax:** `CREATE FOLDER [IF NOT EXISTS] <folder_name>`

### `create_space`

Creates a Space using the REST API. This is specific to **Dremio Software**.

```python
client.admin.create_space("NewSpace")
```

### `create_space_folder`

Creates a folder within a Space using the REST API. This is specific to **Dremio Software**.

```python
client.admin.create_space_folder("NewSpace", "SubFolder")
```

## Differences between Cloud and Software

*   **Dremio Cloud**: Uses `create_folder` for all folder creation. Top-level folders act as spaces.
*   **Dremio Software**: Uses `create_space` for top-level containers (Spaces) and `create_space_folder` for folders within them. `create_folder` can also be used if the backend supports the SQL syntax (e.g. Nessie/Iceberg sources).


---

<!-- Source: docs/admin_governance/tags.md -->

---

## UDF Manager

DremioFrame provides a pythonic interface to manage SQL User Defined Functions (UDFs).

## Usage

Access the UDF manager via `client.udf`.

### Create a UDF

```python
# CREATE FUNCTION my_space.add_ints (x INT, y INT) RETURNS INT RETURN x + y

# Option 1: Using a dictionary for arguments
client.udf.create(
    name="my_space.add_ints",
    args={"x": "INT", "y": "INT"},
    returns="INT",
    body="x + y",
    replace=True
)

# Option 2: Using a string for arguments (useful for complex types)
client.udf.create(
    name="my_space.complex_func",
    args="x INT, y STRUCT<a INT, b INT>",
    returns="INT",
    body="x + y.a",
    replace=True
)
```

### Drop a UDF

```python
client.udf.drop("my_space.add_ints", if_exists=True)
```

### List UDFs

```python
# List all functions matching 'add'
funcs = client.udf.list(pattern="add")
for f in funcs:
    print(f["ROUTINE_NAME"])
```


---

<!-- Source: docs/ai/agent.md -->